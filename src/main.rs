use std::collections::HashMap;
use std::error::Error;
use std::fs::File;
use std::io::{self, BufRead, BufReader};

use regex::Regex;
use walkdir::DirEntry;

mod error;

// This needs to be ignored, generated by the R.swift library
const GENERATED_RESOURCE_FILE_NAME: &str = "R.generated.swift";

fn main() -> Result<(), Box<dyn Error>> {
    println!("Please enter the folder path to the iOS project:");
    let mut input_path = String::new();
    io::stdin().read_line(&mut input_path).expect("Failed to read input.");
    let folder_path = input_path.trim();

    let collected_keys: Vec<String> = collect_string_keys(folder_path)?;

    let key_occurrences = count_key_occurrences(folder_path, &collected_keys)?;

    let keys_with_no_occurrences: Vec<_> = collected_keys.iter()
        .filter(|key| key_occurrences.get(*key).map(|&count| count == 0).unwrap_or(true))
        .collect();

    if keys_with_no_occurrences.is_empty() {
        println!("No unused keys found!")
    } else {
        println!("Following keys are unused:");
        for key in &keys_with_no_occurrences {
            println!("Key: {}", key);
        }
    }

    return Ok(());
}

fn collect_files_with_extension(folder_path: &str, extension: &str) -> Vec<DirEntry> {
    walkdir::WalkDir::new(folder_path)
        .follow_links(true)
        .into_iter()
        .filter_map(|entry| entry.ok())
        .filter(|entry| {
            entry.path().is_file() && entry.path().extension().unwrap_or_default() == extension
        })
        .filter(|entry| {
            entry.path().file_name().unwrap_or_default() != GENERATED_RESOURCE_FILE_NAME
        })
        .collect()
}

fn collect_string_keys(folder_path: &str) -> Result<Vec<String>, Box<dyn Error>> {
    let key_pattern = Regex::new(r#""([^"]+)"\s*=\s*"#).unwrap();

    let mut collected_keys: Vec<String> = Vec::new();

    let string_files = collect_files_with_extension(folder_path, "strings");

    for string_file in string_files {
        let file = File::open(string_file.path()).map_err(|_| error::Error::InvalidPath)?;
        let buffer = BufReader::new(file);

        let keys: Vec<String> = buffer.lines()
            .filter_map(Result::ok)
            .filter_map(|line| {
                key_pattern.captures(&line).and_then(|captures| captures.get(1).map(|m| m.as_str().to_string()))
            })
            .collect();

        collected_keys.extend(keys)
    }

    return Ok(collected_keys);
}

fn count_key_occurrences(folder_path: &str, keys: &[String]) -> Result<HashMap<String, usize>, Box<dyn Error>> {
    let mut key_occurrences: HashMap<String, usize> = HashMap::new();

    let swift_files = collect_files_with_extension(folder_path, "swift");

    for swift_file in swift_files {
        let file = File::open(swift_file.path()).map_err(|_| error::Error::InvalidPath)?;
        let buffer = BufReader::new(file);

        buffer.lines()
            .filter_map(Result::ok)
            .flat_map(|line| {
                keys.iter()
                    .map(|key| (key, format_key(key)))
                    .filter(move |(_, formatted_key)| line.contains(formatted_key))
                    .map(|(original_key, _)| original_key.to_string())
            })
            .for_each(|key| {
                *key_occurrences.entry(key).or_insert(0) += 1;
            })
    }

    return Ok(key_occurrences);
}

fn format_key(key: &str) -> String {
    let mut formatted_key = String::new();
    let mut should_uppercase = false;

    for c in key.chars() {
        if should_uppercase {
            formatted_key.push(c.to_uppercase().next().unwrap());
            should_uppercase = false;
        } else {
            if c == '.' {
                should_uppercase = true;
            } else {
                formatted_key.push(c);
            }
        }
    }

    formatted_key
}